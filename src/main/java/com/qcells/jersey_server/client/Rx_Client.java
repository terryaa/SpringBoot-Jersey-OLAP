package com.qcells.jersey_server.client;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;

import com.qcells.jersey_server.model.Employee;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Rx_Client{
    private static final String REST_URI = "http://172.29.215.113:8080/employees";
    private Client client = ClientBuilder.newClient();
    private Logger logger = LoggerFactory.getLogger(RestClient.class);
    
    public List<String> sendData() throws InterruptedException {
        WebTarget targett=client.target(REST_URI);

        //Parameter of Constructor should be numbers of async requests which will be made. 
        CountDownLatch completionTracker = new CountDownLatch(3);

        List<String> receivedValues=new ArrayList<>(); 

        for(int i=1;i<3;i++){
            //request method returns invoation object, then invocatio objects uses rx() method to
            //make async(reactive) requests. 
            CompletionStage<Employee> completion=targett.path(String.valueOf(i)).request(MediaType.APPLICATION_JSON).rx().get(Employee.class);
            //each async requests made by rx() will execute .thenAccept after callback received from server.
            completion.thenAccept(empp-> {
                receivedValues.add(empp.getFirstName());
                //each async requests will countdown 1 then finish thread.
                completionTracker.countDown();
            });
        }
        //mainthread will try to run whether or not knowing if all thread generated by rx() are finished.6
        if (!completionTracker.await(10, TimeUnit.SECONDS)) {
            logger.warn("Some requests didn't complete within the timeout");
        }
        return receivedValues;
    }
}
   